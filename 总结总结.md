# Leetcode易错点总结
## Math
* random()求解方法 
	* 蓄水池抽样其他的也要看看啊，发现有些朋友用蓄水池用的都魔怔了，一说抽样就是蓄水池。 例如pemutation和shuffle实际上都是个抽样问题。。。。（全排序就是每次选一个字符，shuffle同理）

## String
## Sort
* 自定义排序方法
	* [leetcode123] (https://leetcode.com/problems/two-sum/description/) 举例说明题号

## Tree

* 中序遍历
	* 递归

	```
	class Solution {
	public:
        vector<int> inorder(TreeNode* root) {
        	vector<int>vec;
        	helper(root,vec);
        	return vec;
    	}
    
    	void helper(TreeNode*root, vector<int>&vec){
        	if(!root) return;
        	helper(root->left,vec);
        	vec.push_back(root->val);
        	helper(root->right,vec);
    	}
	};

	
	```
	* 遍历

	```
	class Solution {
	public:
    	vector<int> inorder(TreeNode* root) {
        TreeNode *cur = root;
        vector<int>vec;
        //利用stack后进先出的性质
        stack<TreeNode*> st;
        while(!st.empty() || cur){
        //一直找左子树，没有左子树之后开始出栈，并向右子树的结点移动
            while(cur){
                st.push(cur);
                cur = cur->left;
            }
            cur = st.top();
            st.pop();
            vec.push_back(cur->val);
            cur = cur->right;
        }
        return vec;
    	}
	};

	```
* 前序遍历
* 后序遍历

## Queue
* C++中最小堆priority_queue是大的在前，小的在后

## Binary Search
* 二叉搜索的本质是通过减小搜索的范围来降低时间复杂度，因此数组中可以进行二叉搜索，答案的范围也可以进行二叉搜索

## Others




# Mock发现的问题
### 1.27
* 684
	* 说英语慢慢说，一个单词一个单词说清楚。尽量说的完美，但是不要纠结语法等等，表达出来意思是主要目的。但是速度快了会吞词，再加上思考的语气，自己说的话都听不清楚说的什么。
	* 分析问题如果是本题类似的union find的题目，用图解举例说明是最好的，用了什么方法需要快的写出来。简要表示即可。一来容易解释清楚，二来便于发现思路上的问题。
	* test case非常重要。写完代码第一遍检查是否有typo,第二遍一定要从头到尾过一次original的例子，检查能不能通，是否有忘记判断的if...else条件，再想corner cases.
	* 写代码过程中有卡壳，思考问题在哪，应该用什么方法解决。
	* 在写代码之前，要整体过一遍思路，包括需要什么数据结构完成什么功能，最开始就忘了需要新建一个vector来记录union find。最好再分析一下时间空间复杂度。
	* 如果能够一次性想到很多方法，可以列出1，2，3,不然直接说当前的思路就行。
